set use_sort_nest=1;
create table t0 (a int);
insert into t0 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);
create table t1 (a int, b int);
insert into t1 select a,a from t0 where a <5; # 5 rows
create table t2 as select * from t1 where a < 5; # 5 rows
create table t3(a int, b int, c int, key(a));
insert into t3 select A.a + 10*B.a, A.a + 10*B.a, A.a + 10*B.a from t0 A, t0 B; # 100 rows

--disable_result_log
analyze table t1 persistent for all;
analyze table t2 persistent for all;
analyze table t3 persistent for all;
--enable_result_log

--echo #
--echo # sort-nest(t2,t1)
--echo # ref(sort-nest.b) access on table t3
--echo #

let $query= SELECT t1.a, t2.b, t1.b, t3.a from t1,t2,t3
            WHERE t1.a=t2.a and t2.b=t3.a
            ORDER BY t2.b desc, t1.b desc
            LIMIT 5;

eval EXPLAIN $query;
eval EXPLAIN FORMAT=JSON $query;
eval $query;

drop table t0,t1,t2,t3;

create table ten(a int);
insert into ten values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);

create table one_k(a int);
insert into one_k select A.a + B.a* 10 + C.a * 100 from ten A, ten B, ten C;

create table t1(a int, b int);
insert into t1 select A.a + B.a* 10, A.a + B.a* 10 from ten A, ten B;
create table t2(a int, b int);
insert into t2(a,b) values (1,1), (2,2);
insert into t2 select A.a + B.a* 10, A.a+B.a*10 from ten A, ten B;
create table t3(a int, b int);
insert into t3 select A.a + B.a* 10 + C.a * 100, A.a + B.a* 10 + C.a * 100 from ten A, ten B, ten C;

--disable_result_log
analyze table t1 persistent for all;
analyze table t2 persistent for all;
analyze table t3 persistent for all;
--enable_result_log

delimiter |;
create function f1(a int) returns int
begin
  declare b int default 0;
  return a+b;
end|
delimiter ;|

--echo Covering 3 table joins

--echo
--echo # {t1,t2} part of the nest
--echo # t1.a > 95 would be attached to table t1
--echo # t1.b=t2.a would be attached to table t2;
--echo # t3.a= sort-nest.b would be attached to table t3
--echo

let $query=
select * from t1,t2,t3 where t1.a > 95 and  t1.a=t2.a and t1.b = t3.a order by t2.b limit 5;

alter table t2 add key(a);
eval explain $query;
eval explain format=json $query;
eval $query;

alter table t2 drop key a;

--echo
--echo # {t1,t2} part of the sort nest
--echo # (t2.a < 2 or t1.b > 98) would be attached to table t2
--echo

let $query=
select * from t1,t2,t3 where (t3.a < 2 and t2.a < 2) or (t1.b > 98 and t3.b > 98)
order by t1.a, t2.b limit 5;
eval explain $query;
eval explain format=json $query;
eval $query;

--echo
--echo # {t1,t2} part of the nest
--echo # t2.a < 2 or f1(t1.b) attached to table t2
--echo # t1.b=t2.a would be attached to table t2;
--echo

let $query=
select * from t1,t2,t3 where (t3.a<2  and t2.a <2) or (f1(t1.b) > 98 and t3.b > 98)
order by t1.a,t2.b limit 5;
eval explain $query;
eval explain format=json $query;
eval $query;

--echo #
--echo # Removing constant from the order by clause
--echo #

let $query=
select * from t1,t2 where t1.a > 95  and t1.a=t2.a order by t2.a limit 4;
eval explain $query;
eval explain format=json $query;
eval $query;

let $query=
select * from t1,t2 where t1.a > 95  and t1.a=t2.a order by 1+2,t2.a limit 4;
eval explain $query;
eval explain format=json $query;
eval $query;

--echo #
--echo # Equality propagation, both the queries should use a sort nest on {t1,t2}
--echo #

let $query=select t3.b, t2.a , t1.b , t1.a  from t1,t2,t3 where t1.b=t3.b
order by t1.b desc, t2.a desc limit 3;
eval explain $query;
eval explain format=json $query;
eval $query;

let $query=select t3.b, t2.a , t1.b , t1.a  from t1,t2,t3 where t1.b=t3.b
order by t3.b desc, t2.a desc limit 3;

eval explain $query;
select * from INFORMATION_SCHEMA.OPTIMIZER_TRACE;
eval explain format=json $query;
eval $query;

--echo #
--echo # Equality propagation also for arguments of expressions,
--echo # the plan should use a sort nest on {t1,t2}
--echo #

let $query=select t3.b, t2.a , t1.b , t1.a  from t1,t2,t3 where t1.b=t3.b
order by t3.b+1 desc, t2.a desc limit 3;
eval explain $query;
eval explain format=json $query;
eval $query;

--echo #
--echo # Rows for the sort-nest should be the cardinality of the join of inner tables
--echo # of the sort-nest
--echo #

--echo # Rows for sort nest would be 9894 here
alter table t1 add key(a);
let $query=select t3.b, t2.a , t1.b , t1.a  from t1,t2,t3 where t1.a > 5 and t1.b=t3.b
order by t1.b desc, t2.a desc limit 3;
eval explain extended $query;
alter table t1 drop key a;

--echo #
--echo # With having clause we can't have a sort-nest
--echo #

let $query= select * from t1,t2,t3 where t1.a=t2.a and t1.b = t3.a  having t1.a > 95
order by t2.b,t1.b limit 5;
eval explain $query;
eval explain format=json $query;
eval $query;

let $query=
select * from t1,t2,t3 where t1.a > 95 and  t1.a=t2.a and t1.b = t3.a
order by t2.b,t1.b limit 5;
eval explain $query;
eval explain format=json $query;
eval $query;


--echo #
--echo # Selectivity estimates taken into account for sort-nest{t1,t2}
--echo #

create index idx1 on t1(b);
create index idx2 on t2(a);
create index idx3 on t3(b);

let $query= select * from t1,t2,t3
            where t1.a=t2.a and t1.b = t3.a and t1.b < 5 and t3.b < 900
            order by t2.b limit 5;

eval explain $query;
eval explain format=json $query;
eval $query;

drop index idx1 on t1;
drop index idx2 on t2;
drop index idx3 on t3;
drop table t1,t2,t3,ten,one_k;
drop function f1;

--echo Derived table inside a sort-nest

CREATE TABLE t1 (f1 varchar(1), f2 varchar(1), KEY (f2));
INSERT INTO t1 VALUES
('r','x'), ('x','x'), ('x','x'), ('r','x'), ('x','x');

CREATE TABLE t2 (f1 varchar(1), f2 varchar(1));
INSERT INTO t2 VALUES ('s','x');

CREATE TABLE t3 (f1 varchar(1), f2 varchar(1), KEY (f2));
INSERT INTO t3 VALUES
(NULL,'x'), (NULL,'f'), ('t','x'), (NULL,'j'), ('g','x');

CREATE TABLE t4 (f1 int, f2 varchar(1), KEY (f2,f1)) ;
INSERT INTO t4 VALUES (2,'x'), (1,'x');

let $query= SELECT t.f1 as f
            FROM (SELECT DISTINCT t1.* FROM t1,t2 WHERE t2.f2 = t1.f2) t,t3,t4
            WHERE t4.f2 = t3.f2  AND t4.f2 = t.f1 ORDER BY f limit 10;


eval explain $query;
eval explain format=json $query;
eval $query;

--echo should use the sort-nest too like the query above

let $query= SELECT t4.f1 as f, t.f1 as g
            FROM (SELECT DISTINCT t1.* FROM t1,t2 WHERE t2.f2 = t1.f2) t,t3,t4
            WHERE t4.f2 = t3.f2  AND t4.f2 = t.f1 ORDER BY f,g limit 10;
eval explain $query;
eval explain format=json $query;
eval $query;

drop table t1,t2,t3,t4;

--echo views inside a sort-nest
create table t0 (x int);
create table t1 (a int);
create table t2 (b int, c int default 0);

insert t0 (x) values (0),(10);
insert t1 (a) values (1), (2);
insert t2 (b) values (1), (2);

create view v1 as select t2.b,t2.c from t1, t2
where t1.a=t2.b and t2.b < 3 with check option;

let $query= select * from v1,t0 where b<3 order by x,b desc limit 2;
eval explain $query;
eval explain format=json $query;
eval $query;
drop table t0,t1,t2;
drop view v1;

--echo # Primary key considered as the key that could achieve ordering

create table t1 (id char(32) NOT NULL primary key);
insert into t1 values (0), (1), (2), (3), (4), (5), (6), (7), (8), (9);
create table t2 (id char(32) NOT NULL primary key);
insert into t2 values (0), (1), (2), (3);

let $query= select t1.id from t1 INNER JOIN t2 on t1.id=t2.id order by t2.id limit 2;
eval explain $query;
eval explain format=json $query;
eval $query;

drop table t1,t2;

create table t0 (a int);
insert into t0 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);
create table t1 (a int, b int);
insert into t1 select a,a from t0;
create table t2 as select * from t1;

create table t3 as select (A.a + 10*B.a+C.a*100) as a,
                          (A.a + 10*B.a+C.a*100) as b
                          from t0 A, t0 B,t0 C;

--disable_result_log
analyze table t1 persistent for all;
analyze table t2 persistent for all;
analyze table t3 persistent for all;
--enable_result_log

let $query= select * from t2,t1 left join t3 on t3.a=t1.b
            order by t2.a desc,t1.a desc limit 5;

--echo #
--echo # Outer Join
--echo #

--echo # sort-nest(t2,t1) and t3 outside the nest
eval explain $query;
eval explain format=json $query;
eval $query;

--echo # no sort-nest as all the inner tables of the outer join will be inside the nest
--echo # this should use temporary table to sort after the entire join is computed
let $query= select * from t2 left join (t1 left join t3 on t3.a=t1.b) on t2.b=t1.a
            order by t2.a desc,t1.a desc limit 5;
eval explain $query;
eval explain format=json $query;
eval $query;
drop table t0,t1,t2,t3;

--echo #
--echo # Sort-nest with prepared statements
--echo #

create table t0 (a int);
insert into t0 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);
create table t1 (a int, b int);
insert into t1 select a,a from t0;
create table t2 as select * from t1;

create table t3 (a int, b int);
insert into t3 select (A.a + 10*B.a+C.a*100) as a,
                       (A.a + 10*B.a+C.a*100) as b
                        from t0 A, t0 B,t0 C;

--disable_result_log
analyze table t1 persistent for all;
analyze table t2 persistent for all;
analyze table t3 persistent for all;
--enable_result_log

--echo # sort-nest on table t1,t2
prepare ps1 from "explain select * from t2,t1,t3 where t3.a=t1.b+1 order by t2.a desc,t1.a desc limit 5";
execute ps1;
execute ps1;

--echo # sort-nest on table t1,t2
prepare ps2 from "explain format=json
                    select * from t2,t1,t3 where t3.a=t1.b+1 order by t2.a desc,t1.a desc limit 5";
execute ps2;
execute ps2;

--echo # sort-nest on table t1,t2
prepare ps3 from "select * from t2,t1,t3 where t3.a=t1.b+1 order by t2.a desc,t1.a desc limit 5";
execute ps3;
execute ps3;

deallocate prepare ps1;
deallocate prepare ps2;
deallocate prepare ps3;
drop table t0,t1,t2,t3;

--echo # INDEPENDENT SUBQUERIES

create table t0 (a int);
insert into t0 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);
create table t1 (a int, b int);
insert into t1 select a,a from t0 where a <5;
create table t2 as select * from t1 where a < 5;
create table t3 as select (A.a + 10*B.a+C.a*100) as a, (A.a + 10*B.a+C.a*100) as b,
                          (A.a + 10*B.a+C.a*100) as c from t0 A, t0 B,t0 C; # 1000 rows

--disable_result_log
analyze table t1 persistent for all;
analyze table t2 persistent for all;
analyze table t3 persistent for all;
--enable_result_log

--echo #
--echo # sort-nest(t2,t1) and independent subquery in the select list
--echo #

let $query= select (select t4.a from t3 t4 where t4.a > 5 limit 1) as x, t2.b, t1.b, t3.a from t1,t2,t3
            where t1.a = t2.a order by t2.b desc, t1.b desc limit 5;

eval explain $query;
eval explain format=json $query;
eval $query;

drop table t0,t1,t2,t3;

--echo #
--echo #  Const table should not form the sort-nest
--echo #

CREATE TABLE t1 (i1 integer NOT NULL PRIMARY KEY);
CREATE TABLE t2 (i2 integer NOT NULL PRIMARY KEY);
CREATE TABLE t3 (i3 integer);
INSERT INTO t1 VALUES (1), (2), (3), (4), (5), (6), (7), (8), (9), (10), (11), (12);
INSERT INTO t2 SELECT * FROM t1;
SELECT t1.*, t2.* FROM t1 JOIN t2 ON t1.i1 = t2.i2
LEFT JOIN t3 ON t2.i2 = t3.i3
ORDER BY t1.i1 LIMIT 5;
drop table t1,t2,t3;

--echo # All tables are const tables

create table t1 (a int, b int);
insert into t1 values (0,0);
create table t2(a int, b int);
insert into t2 values (0,0);
create table t3(a int, b int);
insert into t3 values (0,0);

let $query= SELECT t1.a,t2.a,t3.a FROM t1,t2,t3
            WHERE t1.b = t2.b and t3.b=t1.b
            ORDER BY t2.a desc,t1.a desc limit 5;

eval EXPLAIN extended $query;
eval $query;

drop table t1,t2,t3;

--echo #
--echo # Tests where Index(scan, ref or range access) satisfies the ORDERING
--echo #

CREATE TABLE t1 (a int, b int, c int, KEY a_b (a,b), KEY a_c (a,c));

insert into t1 values (0,1,0), (0,2,0), (0,3,0), (0,4,0), (0,5,0), (0,6,0);
insert into t1 values (1,7,1), (1,8,1), (1,9,1), (1,10,1), (1,11,1), (1,12,1);
insert into t1 values (1,7,2), (1,8,2), (1,9,2), (1,10,2), (1,11,2), (1,12,2);
insert into t1 values (1,7,2), (1,8,2), (1,9,2), (1,10,2), (1,11,2), (1,12,2);
insert into t1 values (1,1,2);

--echo # index key a_b, no need for filesort

let $query= select a,b,c from t1 where a=1 and c=2 order by b limit 10;
eval explain $query;
eval $query;
drop table t1;
